
// If cond "$1" is true, do $2, otherwise do $3
sar_function __choose "cond $'$1$' $'$2$'; cond $'!($1)$' $'$3$'"

// 2^31-1
svar_set __i32_max 2147483647

sar_function __tmp_cvar_save    cond "!var:__tmp_init_cvar_$1=1" "svar_set __tmp_init_cvar_$1 1; svar_from_cvar __tmp_cvar_$1 $1"
sar_function __tmp_cvar_restore cond  "var:__tmp_init_cvar_$1=1" "svar_set __tmp_init_cvar_$1 0; sar_expand $1 $$'$$__tmp_cvar_$1$$'"

sar_alias __tmp_toast_save    "__tmp_cvar_save sar_toast_x; __tmp_cvar_save sar_toast_y; __tmp_cvar_save sar_toast_align; __tmp_cvar_save sar_toast_anchor; __tmp_cvar_save sar_toast_disable; __tmp_cvar_save sar_toast_width; __tmp_cvar_save sar_toast_background; __tmp_cvar_save sar_toast_compact; __tmp_cvar_save sar_toast_font"
sar_alias __tmp_toast_restore "__tmp_cvar_restore sar_toast_x; __tmp_cvar_restore sar_toast_y; __tmp_cvar_restore sar_toast_align; __tmp_cvar_restore sar_toast_anchor; __tmp_cvar_restore sar_toast_disable; __tmp_cvar_restore sar_toast_width; __tmp_cvar_restore sar_toast_background; __tmp_cvar_restore sar_toast_compact; __tmp_cvar_restore sar_toast_font"

// Svar capture without clogging console
sar_function svar_capture_quiet "__tmp_cvar_save sar_con_filter; __tmp_cvar_save sar_con_filter_default; sar_con_filter 1; sar_con_filter_default 0; svar_capture $'$1$' $'$2$'; __tmp_cvar_restore sar_con_filter; __tmp_cvar_restore sar_con_filter_default"

// Registers a command to be ran every tick.
// Dependencies: less_than, while
sar_toast_tag_set_color sarontickwarning FF3333
sar_toast_tag_set_duration sarontickwarning forever
sar_function sar_on_tick "sar_function __sar_on_tick_$__sar_on_tick_len $'$1$'; svar_add __sar_on_tick_len 1"
sar_alias sar_on_tick_clear       svar_set __sar_on_tick_len 0
sar_alias sar_on_tick_remove_last svar_sub __sar_on_tick_len 1
sar_on_tick_clear
sar_function __on_tick "svar_set __on_tick_i 0; sar_expand less_than $$__on_tick_i $__sar_on_tick_len; while $'var:less_than_ret=1$' $'sar_expand __sar_on_tick_$$__on_tick_i; svar_add __on_tick_i 1; sar_expand less_than $$__on_tick_i $__sar_on_tick_len$'"
sar_function sar_on_tick_enable  cond "!var:__on_tick_init=1" sar_expand "sar_toast_create sarontickwarning $$'No runs! sar_on_tick enabled$$'; sar_alias _on_tick seq __on_tick _on_tick; _on_tick; svar_set __on_tick_init 1"
sar_function sar_on_tick_disable cond  "var:__on_tick_init=1" "sar_toast_tag_dismiss_all sarontickwarning; sar_alias _on_tick nop; svar_set __on_tick_init 0"

// Returns 1 if $1 < 0, otherwise 0
// Updated from RainbowPhoenixx's version
// Return variable: neg_ret
sar_function neg "svar_set neg_ret 1; svar_set __tmp_neg $'$1$'; svar_add __tmp_neg 0; svar_append __tmp_neg __i32_max; svar_sub __tmp_neg __i32_max; cond $'var:__tmp_neg=0$' svar_set neg_ret 0"

// Returns 1 if $1 < $2, otherwise 0
// Updated from RainbowPhoenixx's version
// Return variable: less_than_ret
// Dependencies: neg
sar_function less_than "svar_set __tmp_less_than $'$1$'; svar_sub __tmp_less_than $'$2$'; sar_expand $'neg $$__tmp_less_than$'; sar_expand $'svar_set less_than_ret $$neg_ret$'"

// Get current session tick
// Updated from mlugg's version
// Return variable: gettick_ret
// Dependencies: svar_capture_quiet
sar_function gettick  "svar_capture_quiet gettick_ret sar_session; sar_expand __gettick $$gettick_ret"
sar_function __gettick "svar_set gettick_ret $4"

// Generates a random number such that 0 <= n < $1
// Updated from RainbowPhoenixx's version
// https://en.wikipedia.org/wiki/Linear_congruential_generator
// Return variable: rand_ret
// Dependencies: gettick, neg
svar_set __lcg_a 1103515
svar_set __lcg_b 12345
svar_set __lcg_m 42949672
sar_alias lcg_set_state svar_set lcg_state
sar_function lcg_init_seed "gettick; sar_expand lcg_set_state $$gettick_ret"
sar_function lcg_advance_state "svar_mul lcg_state __lcg_a; svar_add lcg_state __lcg_b; svar_mod lcg_state __lcg_m; sar_expand neg $$lcg_state; cond $'var:neg_ret=1$' svar_add lcg_state __i32_max"
sar_on_config_exec lcg_init_seed // introduces some base randomness since config exec is based on network
sar_function __rng "lcg_advance_state; sar_expand svar_set $1_ret $$__lcg_state; svar_mod $1_ret $2"
sar_function rng    "__rng rng $1"
sar_alias    rand   "__rng rand $1"
sar_alias    random "__rnd random $1"

// Appends / prepends the contents of svar $2 to svar $1
sar_function svar_append  sar_expand svar_set "$1" "$$$1$$$2"
sar_function svar_prepend sar_expand svar_set "$1" "$$$2$$$1"

// Sets svar $1 to its absolute value
// Dependencies: neg
sar_function svar_abs "sar_expand neg $'$$$1$'; cond $'var:neg_ret=1$' sar_expand $'svar_set __tmp_abs $$'$$$1$$'; svar_mul __tmp_abs 2; svar_sub $$'$1$$' __tmp_abs$'"

// Repeats command $1 $2 times
// Dependencies: neg
sar_function repeat "svar_set __tmp_repeat $'$2$'; svar_sub __tmp_repeat 1; sar_expand neg $$__tmp_repeat; cond $'var:neg_ret=0$' sar_expand $'$1; repeat $$'$1$$' $$__tmp_repeat$'"

// Repeats command $2 while cond $1 is true
svar_set while_limit 500
sar_function while   "svar_set while_i 0; _while $'$1$' $'$2$'"
sar_function _while  "svar_add while_i 1; cond $'$1$' __while $'$1$' $'$2$'"
sar_function __while "$2; cond $'var:while_i=$while_limit$' echo $'While recursion limit ($while_limit) reached$'; cond $'!var:while_i=$while_limit$' _while $'$1$' $'$2$'"
